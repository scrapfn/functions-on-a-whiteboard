---
layout: posts
title:  Function Lifting
---

 In the previous post we looked at the algebra of functions.

```
(f+g)(x)  =  f(x) + g(x)
(f-g)(x)  =  f(x) - g(x)
(f*g)(x)  =  f(x) * g(x)
(f/g)(x)  =  f(x) / g(x)
...
```

 Defining functions this way is tedious since we can easily recognize the pattern. Describing the pettern verbally is possible but it will never get as concise as defining them as a mathematical expression.

 We can utilize the notion of higher order functions that we established in the last post to **describe the pattern with a function**.

The pattern we see is:
`(f op g)(x) = f(x) op g(x)`
where op is replaced by a function on real numbers.

To describe the patten we first list all the variables in the above expression.
`op, f, g, x`

Then write a function that has all these variables. Call it the `lift`.
`lift(op,f,g,x) = f(x) op g(x)`

Remember binary operators are equivalent to functions with two variables. Let's rewrite it for consistency, and this is your lift right here.

```
lift(op,f,g,x) = op(f(x), g(x))
```

The usage of the lift is straight forward. Feed a function on numbers to the lift and name it whatever you like.

```
_+_ = lift(+)
_-_ = lift(-)
_*_ = lift(*)
_/_ = lift(/)


=====EXAMPLE=====

let f(x) = x*2
    g(x) = x+3
    f+g = _+_(f,g)
    f-g = _-_(f,g)
    f*g = _*_(f,g)
    f/g = _/_(f,g)
in
    f+g(4)     evaluates to 8+7 = 15
    f-g(4)     evaluates to 8-7 = 1
    f*g(4)     evaluates to 8*7 = 56
    f/g(4)     evaluates to 8/7
```

Lift frees you from writing and reading the boilerplate over and over again. It generalizes the process of making the functions for numbers applicable for functions. The act of generalizing a pattern with a function is called **abstraction**. Abstraction is extremely important in functional programming because it makes the code shorter and arguably more readable.
